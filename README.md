# Final-Task
Работу выполнин Николаев Олег.

Данная работа необходима для проверки знаний и навыков по итогу прохождения первого блока обучения на программе разработчик.
Для выполнения работы необходимо выполнить следующий алгоритм:
Задание:Выбрать из массива строк те строки, длинна которых меньше или равна трем

Решение: решаем используя три метода.

Метод Array - запрашивает у пользователя любые значения и заполняет ими создаваемый массив
Метод PrintArray - распечатывает заданный массив
Метод MinArray - создает новый массив, состоящий из элементов созданного ранее массива, длина которых меньше или равна трем.
Боле подробно о третьем методе,

сначала, в цикле, подсчитываем сколько в первом массиве элементов, длина которых меньше или равна трем. Это количество будет длинной нового массива;
далее создаем новый массив с длинной, которую мы определили на первом цикле;
во втором цикле записываем в созданный массив те элементы из старого массива, длинна которых меньше или равна трем;
возвращием этот заполненный массив.
Создать репозиторий на GitHub;
Нарисовать блок-схему алгоритма (находится в папке "Final Task");
Создать файл "README.md" и сделать оформление репозитория;
Написать программу;
Использовать контроль версий в работе.
Условие задачи контрольной работы:
Написать программу, которая из имеюшегося массива строк формирует массив из строк, длина которых меньше либо равна 3 символа. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

Решение задачи контрольнй работы:
Исходный массив будет изначально задан 
Алгоритм решения:
Создаем строковый массив, с помощью метода и выводим его. Это будет наш исходный массив;
Создаем второй метод, в котором указываем строковый массив.
Далее создаем цикл, в котором будут перебираться элементы массива.
В теле цикла создаем условие перебора, требующееся по условию задачи.
Если условие удовлетворяется, то из ячейки нового массива произойдёт запись текущего элемента в ячейку исходного массива.
Затем выведем полученный результат.
